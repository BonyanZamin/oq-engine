# -*- coding: utf-8 -*-
# vim: tabstop=4 shiftwidth=4 softtabstop=4
#
# Copyright (C) 2023, GEM Foundation
#
# OpenQuake is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# OpenQuake is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with OpenQuake.  If not, see <http://www.gnu.org/licenses/>.
"""
Median spectrum post-processor
"""
import logging
import numpy as np
from openquake.baselib import sap, parallel, general
from openquake.hazardlib import contexts


def set_imls(cmaker, uhs):
    """
    Replace the imtls with the values in the uniform hazard spectrum (one
    level per IMT).
    """
    imtls = {}
    loglevs = {}
    for imt, value in zip(cmaker.imts, uhs):
        imtls[imt] = [value]
        loglevs[imt] = [np.log(value)]
    cmaker.imtls = general.DictArray(imtls)
    cmaker.loglevels = general.DictArray(loglevs)
    return cmaker


def compute_median_spectrum(cmaker, ctx, ref_poe, monitor):
    """
    For a given group, computes the median hazard spectrum using a weighted
    mean based on the poes.

    :param cmaker: ContextMaker for a group of sources
    :param ctx: context array generated by the group of sources
    :param ref_poe: reference PoE for the spectrum
    :param ref_uhs: the mean UHS associated to the PoE
    """
    weights = []
    for poes, ctxt, _inv in cmaker.gen_poes(ctx):
        C, M, G = poes.shape
        if np.isfinite(ctxt[0].occurrence_rate):
            ocr = ctxt.occurrence_rate
        else:
            probs = [rup.probs_occur[0] for rup in ctxt]
            ocr = -np.log(probs) / cmaker.investigation_time
        ws = np.empty((C, M, G), np.float32)
        for g, w in enumerate(cmaker.wei):
            for m in range(M):
                ws[:, m, g] = ocr * poes[:, m, g] * w / ref_poe
        weights.append(ws)

    mea, _, _, _ = cmaker.get_mean_stds([ctx])  # shape (G, M, N)
    wei = np.concatenate(weights)  # shape (N, M, G)
    median_spectrum = np.einsum('nmg,gmn->m', wei, mea)

    return {'grp_id': [cmaker.grp_id], 'mhs': median_spectrum}


def main(dstore, ref_poe):
    """
    Compute the median hazard spectrum for the reference poe,
    starting from the already stored mean hazard spectrum.

    :param dstore: DataStore of the parent calculation
    :param ref_poe: reference PoE for the spectrum
    """
    # consistency checks
    oqp = dstore['oqparam']
    N = len(dstore['sitecol'])
    M = len(oqp.imtls)
    assert ref_poe in oqp.poes, (ref_poe, oqp.poes)
    assert oqp.investigation_time == 1, oqp.investigation_time
    assert 'PGV' not in oqp.imtls
    assert N == 1, N
    logging.warning('Median spectrum calculations are still '
                    'experimental')

    # read the precomputed mean hazard spectrum
    uhs = dstore.sel('hmaps-stats', stat='mean', poe=ref_poe)
    ref_uhs = uhs[0, 0, :, 0]  # shape SNMP -> M
    cmakers = contexts.read_cmakers(dstore)
    ctx_by_grp = contexts.read_ctx_by_grp(dstore)
    
    smap = parallel.Starmap(compute_median_spectrum, h5=dstore)
    for grp_id, ctx in ctx_by_grp.items():
        # reduce the levels to 1 level per IMT
        cmaker = set_imls(cmakers[grp_id], ref_uhs)
        smap.submit((cmaker, ctx, ref_poe))
    res = smap.reduce()

    # save the median_spectrum
    mhs = np.zeros(M, [('period', np.float32), ('iml', np.float32)])
    mhs['period'] = [imt.period for imt in oqp.imt_periods()]
    mhs['iml'] = res['mhs']
    dstore.create_dset('median_spectrum', mhs, fillvalue=None)


if __name__ == '__main__':
    sap.run(main)
